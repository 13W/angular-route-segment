{"name":"angular-route-segment","tagline":"An extension for AngularJS $route service which supports tree-like nested views and routes hierarchy, and advanced flow handling.","body":"Getting Started\r\n-------\r\n\r\nExample site is located here: \r\n\r\n> [**DEMO SITE**](http://angular-route-segment.com/src/example/)\r\n\r\nThe sources of this example can be found in the folder [/example](https://github.com/artch/angular-route-segment/tree/master/example).\r\n\r\nYou can install the library via [Bower](http://bower.io/):\r\n```\r\nbower install angular-route-segment\r\n```\r\nOr use this CDN link (thanks to [cdnjs.com](http://cdnjs.com)):\r\n```html\r\n<script src=\"//cdnjs.cloudflare.com/ajax/libs/angular-route-segment/1.2.3/angular-route-segment.min.js\"></script>\r\n```\r\n\r\nTested with AngularJS 1.1.5 and 1.2.0rc1 (you must include `ngRoute` module in 1.2.x!).\r\n\r\nOverview\r\n--------\r\n\r\nThis library is intended to provide the lacking functionality of nested routing to AngularJS applications. It is widely known, there are no ways to keep the page state unchanged when only a part of it should be updated via routing mechanics - the `$route` service re-creates the whole scope after a route is changed, losing its state completely. **route-segment** gives you a way to handle this.\r\n\r\nThe library provides two pieces of code: `$routeSegment` service and `app-view-segment` directive. Both are placed in their own modules which you must include as dependencies in your app module:\r\n\r\n```javascript\r\nvar app = angular.module('app', ['ngRoute', 'route-segment', 'view-segment']);\r\n```\r\n\r\n`$routeSegment` is meant to be used instead of built-in Angular `$route` service. Its provider exposes configuration methods which can be used to traverse the tree of route segments and setup it properly.\r\n\r\n```javascript\r\n\r\napp.config(function ($routeSegmentProvider) {\r\n\r\n$routeSegmentProvider.\r\n\r\n    when('/section1',          's1.home').\r\n    when('/section1/prefs',    's1.prefs').\r\n    when('/section1/:id',      's1.itemInfo.overview').\r\n    when('/section1/:id/edit', 's1.itemInfo.edit').\r\n    when('/section2',          's2').\r\n\r\n    segment('s1', {\r\n        templateUrl: 'templates/section1.html',\r\n        controller: MainCtrl}).\r\n\r\n    within().\r\n\r\n        segment('home', {\r\n            templateUrl: 'templates/section1/home.html'}).\r\n\r\n        segment('itemInfo', {\r\n            templateUrl: 'templates/section1/item.html',\r\n            controller: Section1ItemCtrl,\r\n            dependencies: ['id']}).\r\n\r\n        within().\r\n\t    \r\n            segment('overview', {\r\n                templateUrl: 'templates/section1/item/overview.html'}).\r\n\r\n            segment('edit', {\r\n                 templateUrl: 'templates/section1/item/edit.html'}).\r\n\r\n            up().\r\n\r\n        segment('prefs', {\r\n            templateUrl: 'templates/section1/prefs.html'}).\r\n\r\n        up().\r\n\r\n    segment('s2', {\r\n        templateUrl: 'templates/section2.html',\r\n        controller: MainCtrl});\r\n```\r\n\r\nAlternatively, you can use this syntax instead of traversing:\r\n\r\n```javascript\r\n$routeSegmentProvider.segment('s1', {\r\n    templateUrl: 'templates/section1.html',\r\n    controller: MainCtrl});\r\n\r\n$routeSegmentProvider.within('s1').segment('home', {\r\n    templateUrl: 'templates/section1/home.html'});\r\n\r\n$routeSegmentProvider.within('s1').segment('itemInfo', {\r\n    templateUrl: 'templates/section1/item.html',\r\n    controller: Section1ItemCtrl,\r\n    dependencies: ['id']});\r\n    \r\n$routeSegmentProvider.within('s1').within('itemInfo').segment('overview', {\r\n    templateUrl: 'templates/section1/item/overview.html'});\r\n```\r\n\r\nThen, any `app-view-segment` tags (which are similar to built-in `ng-view`) in the DOM will be populated with the corresponding route segment item. You must provide a segment index as an argument to this directive to make it aware about which segment level in the tree it should be linked to.\r\n\r\n**index.html:**\r\n```html\r\n<ul>\r\n    <li ng-class=\"{active: $routeSegment.startsWith('s1')}\">\r\n        <a href=\"/section1\">Section 1</a>\r\n    </li>\r\n    <li ng-class=\"{active: $routeSegment.startsWith('s2')}\">\r\n        <a href=\"/section2\">Section 2</a>\r\n    </li>\r\n</ul>\r\n<div id=\"contents\" app-view-segment=\"0\"></div>\r\n```\r\n\r\n**section1.html:** (it will be loaded to `div#contents` in `index.html`)\r\n```html\r\n<h4>Section 1</h4>\r\nSection 1 contents.\r\n<div app-view-segment=\"1\"></div>\r\n```\r\n\r\n...etc. You can reach any nesting level here. Every view will be handled independently, keeping the state of top-level views.\r\n\r\nDifference from UI-Router\r\n-------------------------\r\n\r\nWhile it seems that this library has very similar goal to what [UI-Router](https://github.com/angular-ui/ui-router/) provides, there are some important differences between their implementations, though.\r\n\r\n*UI-Router* implements its own URL routing mechanics with its own \"state\" concept on top of it. *angular-route-segment* doesn't try to replace something in AngularJS. It is based on built-in `$route` engine, so that it tries to extend it rather than to replace. `$routeSegmentProvider.when` method is just a shorthand to `$routeProvider.when` with the simplified syntax. Inner segment-handling logic is built on top of events propagated by `$route` service, with internal usage of some route params from it.\r\n\r\nSuch approach makes it possible to accomplish the desired nested routing task in more simpler manner, which produces less code, less complexity and potential bugs, provides better cohesion with Angular core engine and is easier to understand, use and debug.\r\n\r\nDocumentation\r\n-------------\r\n\r\nPlease note that you may read the [test specs](https://github.com/artch/angular-route-segment/tree/master/test/unit) to learn features usage.\r\n\r\n### $routeSegmentProvider properties ###\r\n\r\n##### options\r\n\r\nA hash object which can be used to set up the service on config stage:\r\n\r\n- *options.autoLoadTemplates*\r\n\r\n    When true, it will resolve `templateUrl` automatically via $http service and put its contents into `template`.\r\n    \r\n- *options.strictMode* \r\n\r\n    When true, all attempts to call `within` method on non-existing segments will throw an error (you would usually want this behavior in production). When false, it will transparently create new empty segment (can be useful in isolated tests).\r\n\r\n##### when(route, name)\r\n\r\nThe shorthand for $routeProvider.when() method with specified fully qualified route name.\r\n\r\n- *route*\r\n\r\n    Route URL, e.g. `/foo/bar`\r\n    \r\n- *name*\r\n    \r\n    Fully qualified route name, e.g. `foo.bar`\r\n\r\n##### segment(name, params)\r\n\r\nAdds new segment at current pointer level.\r\n\r\n- *name*\r\n\r\n    Name of a segment item, e.g. `bar`\r\n    \r\n- *params*\r\n\r\n    Segment's parameters hash. The following params are supported:\r\n    \r\n    - `template` provides HTML for the given segment view;\r\n    - `templateUrl` is a template which should be fetched from the network via this URL;\r\n    - `controller` is attached to the given segment view when compiled and linked, this can be any controller definition AngularJS supports;\r\n    - `controllerAs` is a controller alias name, if present the controller will be published to scope under the\r\n    controllerAs name;\r\n    - `dependencies` is an array of route param names which are forcing the view to recreate when changed;\r\n    - `watcher` is a $watch-function for recreating the view when its returning value is changed;\r\n    - `resolve` is a hash of functions or injectable names which should be resolved prior to instantiating the template and the controller;\r\n    - `untilResolved` is the alternate set of params (e.g. `template` and `controller`) which should be used before resolving is completed; \r\n    - `resolveFailed` is the alternate set of params which should be used if resolving failed.\r\n    \r\n##### within(childName)\r\n\r\nTraverses into an existing segment, so that subsequent `segment` calls will add new segments as its descendants.\r\n             \r\n- *childName* \r\n\r\n    An existing segment's name. An optional argument. If undefined, then the last added segment is selected.\r\n    \r\n##### up()\r\n \r\nTraverses up in the tree.\r\n\r\n##### root()\r\n \r\nTraverses to the root.\r\n \r\n### $routeSegment properties ###\r\n \r\n##### name\r\n\r\nFully qualified name of current active route.\r\n\r\n##### $routeParams\r\n\r\nA copy of `$routeParams` in its state of the latest successful segment update. It may be not equal to `$routeParams`\r\nwhile some resolving is not completed yet. Should be used instead of original `$routeParams` in most cases.\r\n\r\n##### chain\r\n\r\nAn array of segments splitted by each level separately. Each item contains the following properties:\r\n\r\n- `name` is the name of a segment;\r\n- `params` is the config params hash of a segment;\r\n- `locals` is a hash which contains resolve results if any;\r\n- `reload` is a function to reload a segment (restart resolving, reinstantiate a controller, etc)\r\n\r\n##### startsWith(val)\r\n\r\nHelper method for checking whether current route starts with the given string.\r\n\r\n##### contains(val)\r\n\r\nHelper method for checking whether current route contains the given string.\r\n\r\n\r\nLicense\r\n-------\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013 Artem Chivchalov\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"UA-43203231-1","note":"Don't delete this file! It's used internally to help with page regeneration."}